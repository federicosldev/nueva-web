---

---

<!-- <section
    class="bg-lightpurple-pattern flex flex-col items-center justify-center text-center pt-16 md:pt-[100px] lg:pt-[160px] pb-20 md:pb-[150px] lg:pb-[200px]"
>
    <div class="w-full max-w-[1140px] px-4">
        <h2
            class="text-6xl md:text-5xl lg:text-7xl xl:text-9xl text-primary-purple uppercase"
        >
            Una vez que tenemos claros tus objetivos,
        </h2>
        <p
            class="text-2xl md:text-2xl lg:text-4xl xl:text-5xl text-primary-purple uppercase font-bold mt-6"
        >
            Podemos desarrollar una estrategia y un plan para alcanzarlos. Esto
            incluirá la identificación de los pasos necesarios, los recursos y
            los posibles obstáculos a superar.
        </p>
    </div>
</section> -->---
---
<section
    class="physics-section bg-lightpurple-pattern flex flex-col items-center justify-center text-center pt-16 md:pt-[100px] lg:pt-[160px] pb-20 md:pb-[150px] lg:pb-[200px] relative overflow-hidden"
>
    <div
        class="content relative z-10 w-full max-w-[1140px] px-4 pointer-events-none"
    >
        <h2
            class="text-6xl md:text-5xl lg:text-7xl xl:text-9xl text-primary-purple uppercase"
        >
            Una vez que tenemos claros tus objetivos,
        </h2>
        <p
            class="text-2xl md:text-2xl lg:text-4xl xl:text-5xl text-primary-purple uppercase font-bold mt-6"
        >
            Podemos desarrollar una estrategia y un plan para alcanzarlos. Esto
            incluirá la identificación de los pasos necesarios, los recursos y
            los posibles obstáculos a superar.
        </p>
    </div>
    <div class="physics-boundary absolute z-0 hidden lg:block"></div>
    <div class="physics-container absolute z-0 hidden lg:block"></div>
</section>

<script>
    import Matter from 'matter-js';

    function getScaleFactor() {
        const width = window.innerWidth;
        const baseWidth = 1920; // Ancho de referencia para pantalla grande
        const minScale = 0.35; // Escala mínima para evitar que los elementos sean demasiado pequeños
        const scale = Math.max(minScale, width / baseWidth);
        return scale;
    }

    function initPhysics() {
        if (window.innerWidth < 1024) return;

        const Engine = Matter.Engine;
        const Render = Matter.Render;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Mouse = Matter.Mouse;
        const MouseConstraint = Matter.MouseConstraint;
        const Runner = Matter.Runner;

        const container = document.querySelector('.physics-container');
        const boundary = document.querySelector('.physics-boundary');
        if (!container || !boundary) return;

        const content = document.querySelector('.content');
        if (!content) return;

        const updateContainerDimensions = () => {
            const section = container.closest('.physics-section');
            if (section) {
                const contentRect = content.getBoundingClientRect();
                const sectionRect = section.getBoundingClientRect();
                const contentBottom = contentRect.bottom - sectionRect.top;

                container.style.top = `${contentBottom}px`;
                container.style.height = `${sectionRect.height - contentBottom}px`;
                boundary.style.top = `${contentBottom}px`;
                boundary.style.height = `${sectionRect.height - contentBottom}px`;

                return {
                    width: container.clientWidth,
                    height: container.clientHeight,
                    contentBottom,
                };
            }
            return null;
        };

        const dimensions = updateContainerDimensions();
        if (!dimensions) return;

        const engine = Engine.create({
            gravity: { x: 0, y: 1, scale: 0.001 },
        });

        const render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: dimensions.width,
                height: dimensions.height,
                wireframes: false,
                background: 'transparent',
                pixelRatio: window.devicePixelRatio,
            },
        });

        const runner = Runner.create();
        Runner.run(runner, engine);

        const scaleFactor = getScaleFactor();
        const baseSize = {
            small: 150,
            medium: 180,
            large: 220,
        };

        const items = [
            {
                type: 'text',
                content: 'DESIGN',
                width: baseSize.small * scaleFactor,
                height: 60 * scaleFactor,
            },
            {
                type: 'image',
                content:
                    'https://hebbkx1anhila5yf.public.blob.vercel-storage.com/image-iiWctC0jibsNzjYbGJvCcuH3UQacfC.png',
                width: baseSize.medium * scaleFactor,
                height: 60 * scaleFactor,
            },
            {
                type: 'text',
                content: 'USER EXPERIENCE',
                width: baseSize.large * scaleFactor,
                height: 60 * scaleFactor,
            },
            {
                type: 'text',
                content: 'INSPIRATION',
                width: baseSize.medium * scaleFactor,
                height: 60 * scaleFactor,
            },
            {
                type: 'text',
                content: 'E-COMMERCE',
                width: baseSize.medium * scaleFactor,
                height: 60 * scaleFactor,
            },
            {
                type: 'text',
                content: 'MOTION GRAPHIC',
                width: baseSize.large * scaleFactor,
                height: 60 * scaleFactor,
            },
            {
                type: 'text',
                content: 'WEB DESIGN',
                width: baseSize.medium * scaleFactor,
                height: 60 * scaleFactor,
            },
            {
                type: 'text',
                content: 'BRAND',
                width: baseSize.small * scaleFactor,
                height: 60 * scaleFactor,
            },
            {
                type: 'text',
                content: 'USER INTERFACE',
                width: baseSize.large * scaleFactor,
                height: 60 * scaleFactor,
            },
            {
                type: 'text',
                content: 'PROTOTYPING',
                width: baseSize.medium * scaleFactor,
                height: 60 * scaleFactor,
            },
            {
                type: 'text',
                content: 'TECHNOLOGY',
                width: baseSize.medium * scaleFactor,
                height: 60 * scaleFactor,
            },
        ];

        const walls = [
            Bodies.rectangle(
                dimensions.width / 2,
                dimensions.height + 30,
                dimensions.width,
                60,
                {
                    isStatic: true,
                    friction: 0.8,
                    restitution: 0.2,
                    render: { fillStyle: 'transparent' },
                },
            ),
            Bodies.rectangle(0, dimensions.height / 2, 60, dimensions.height, {
                isStatic: true,
                friction: 0.8,
                restitution: 0.2,
                render: { fillStyle: 'transparent' },
            }),
            Bodies.rectangle(
                dimensions.width,
                dimensions.height / 2,
                60,
                dimensions.height,
                {
                    isStatic: true,
                    friction: 0.8,
                    restitution: 0.2,
                    render: { fillStyle: 'transparent' },
                },
            ),
        ];

        function createPillCanvas(item) {
            const scale = window.devicePixelRatio || 1;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = item.width * scale;
            canvas.height = item.height * scale;
            ctx.scale(scale, scale);

            ctx.fillStyle = '#fff';
            const radius = item.height / 2;
            ctx.beginPath();
            ctx.moveTo(radius, 0);
            ctx.lineTo(item.width - radius, 0);
            ctx.arcTo(item.width, 0, item.width, radius, radius);
            ctx.arcTo(
                item.width,
                item.height,
                item.width - radius,
                item.height,
                radius,
            );
            ctx.lineTo(radius, item.height);
            ctx.arcTo(0, item.height, 0, item.height - radius, radius);
            ctx.arcTo(0, 0, radius, 0, radius);
            ctx.closePath();
            ctx.fill();

            if (item.type === 'text') {
                ctx.fillStyle = '#6b46c1';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const fontSize = Math.floor(24 * scaleFactor);
                ctx.font = `bold ${fontSize}px Darker Grotesque`;
                ctx.fillText(item.content, item.width / 2, item.height / 2);
            }

            return canvas;
        }

        const bodies = items.map(item => {
            const canvas = createPillCanvas(item);

            const commonProperties = {
                friction: 0.8,
                restitution: 0.2,
                density: 0.001,
                chamfer: { radius: 20 * scaleFactor },
                render: {
                    sprite: {
                        texture: canvas.toDataURL(),
                        xScale: 1,
                        yScale: 1,
                    },
                },
            };

            const body = Bodies.rectangle(
                Math.random() * (dimensions.width - item.width) +
                    item.width / 2,
                dimensions.height - 100,
                item.width,
                item.height,
                commonProperties,
            );

            if (item.type === 'image') {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.src = item.content;
                img.onload = () => {
                    const canvas = createPillCanvas(item);
                    const ctx = canvas.getContext('2d');
                    const scale = window.devicePixelRatio || 1;

                    const aspectRatio = img.width / img.height;
                    let drawWidth = item.width * 0.8 * scale;
                    let drawHeight = drawWidth / aspectRatio;

                    if (drawHeight > item.height * 0.8 * scale) {
                        drawHeight = item.height * 0.8 * scale;
                        drawWidth = drawHeight * aspectRatio;
                    }

                    const x = (item.width * scale - drawWidth) / 2;
                    const y = (item.height * scale - drawHeight) / 2;

                    ctx.drawImage(img, x, y, drawWidth, drawHeight);
                    body.render.sprite.texture = canvas.toDataURL();
                };
            }

            return body;
        });

        const mouse = Mouse.create(boundary);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: { visible: false },
            },
        });

        World.add(engine.world, [...walls, ...bodies, mouseConstraint]);
        Render.run(render);

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (window.innerWidth < 1024) {
                    World.clear(engine.world);
                    Engine.clear(engine);
                    render.canvas.remove();
                    return;
                }

                const newDimensions = updateContainerDimensions();
                if (!newDimensions) return;

                render.canvas.width = newDimensions.width;
                render.canvas.height = newDimensions.height;
                render.options.width = newDimensions.width;
                render.options.height = newDimensions.height;

                Matter.Body.setPosition(
                    walls[0],
                    Matter.Vector.create(
                        newDimensions.width / 2,
                        newDimensions.height + 30,
                    ),
                );
                Matter.Body.setPosition(
                    walls[2],
                    Matter.Vector.create(
                        newDimensions.width,
                        newDimensions.height / 2,
                    ),
                );

                World.clear(engine.world);
                Engine.clear(engine);
                initPhysics();
            }, 250);
        });
    }

    document.addEventListener('astro:page-load', initPhysics);
</script>

<style>
    .physics-section {
        min-height: 80vh;
        position: relative;
        overflow: hidden;
    }

    .physics-container {
        width: 100%;
        position: absolute;
        inset: 0;
        pointer-events: none;
    }

    .physics-boundary {
        width: 100%;
        position: absolute;
        inset: 0;
        pointer-events: auto;
    }

    .physics-container canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .content {
        position: relative;
        z-index: 10;
        text-align: center;
    }
</style>
