---
interface Props {
    title: string;
}

const { title } = Astro.props;
---

<section
    class="physics-section bg-lightpurple-pattern flex flex-col items-center justify-center text-center pt-16 md:pt-[100px] lg:pt-[160px] pb-20 md:pb-[150px] lg:pb-[200px] relative overflow-hidden"
>
    <div
        class="content relative z-10 w-full max-w-[1140px] px-4 pointer-events-none"
    >
        <h2
            class="text-6xl md:text-5xl lg:text-7xl xl:text-9xl text-primary-purple uppercase"
        >
            Una vez que tenemos claros tus objetivos,
        </h2>
        <p
            class="text-2xl md:text-2xl lg:text-4xl xl:text-5xl text-primary-purple uppercase font-bold mt-6"
        >
            Podemos desarrollar una estrategia y un plan para alcanzarlos. Esto
            incluirá la identificación de los pasos necesarios, los recursos y
            los posibles obstáculos a superar.
        </p>
    </div>
    <div class="physics-boundary absolute z-0 hidden lg:block"></div>
    <div class="physics-container absolute z-0 hidden lg:block"></div>
</section>

<script>
    import Matter from 'matter-js';

    function initPhysics() {
        if (window.innerWidth < 1024) return;

        const Engine = Matter.Engine;
        const Render = Matter.Render;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Mouse = Matter.Mouse;
        const MouseConstraint = Matter.MouseConstraint;
        const Runner = Matter.Runner;

        let isRunning = false;
        let bodies = [];

        const container = document.querySelector('.physics-container');
        const boundary = document.querySelector('.physics-boundary');
        if (!container || !boundary) return;

        const content = document.querySelector('.content');
        if (!content) return;

        const updateContainerDimensions = () => {
            const section = container.closest('.physics-section');
            if (section) {
                const contentRect = content.getBoundingClientRect();
                const sectionRect = section.getBoundingClientRect();
                const contentBottom = contentRect.bottom - sectionRect.top;

                container.style.top = `${contentBottom}px`;
                container.style.height = `${sectionRect.height - contentBottom}px`;
                boundary.style.top = `${contentBottom}px`;
                boundary.style.height = `${sectionRect.height - contentBottom}px`;

                return {
                    width: container.clientWidth,
                    height: container.clientHeight,
                    contentBottom,
                };
            }
            return null;
        };

        const dimensions = updateContainerDimensions();
        if (!dimensions) return;

        const engine = Engine.create({
            gravity: { x: 0, y: 1, scale: 0.0008 }, // Reducida la gravedad para una caída más suave
        });

        const render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: dimensions.width,
                height: dimensions.height,
                wireframes: false,
                background: 'transparent',
                pixelRatio: window.devicePixelRatio,
            },
        });

        const runner = Runner.create();

        const getSizeConfig = () => {
            const largeScreen = {
                baseScale: 1,
                fontSize: 24,
                chamferRadius: 15,
                imageScale: 0.8,
                density: 0.001,
                friction: 0.8,
                restitution: 0.2,
                heightMultiplier: 1,
            };

            const mediumScreen = {
                baseScale: 0.7,
                fontSize: 18,
                chamferRadius: 12,
                imageScale: 0.9,
                density: 0.002,
                friction: 0.9,
                restitution: 0.15,
                heightMultiplier: 0.8,
            };

            return window.innerWidth >= 1536 ? largeScreen : mediumScreen;
        };

        const getItemDimensions = baseWidth => {
            const config = getSizeConfig();

            return {
                width: Math.round(baseWidth * config.baseScale),
                height: Math.round(60 * config.heightMultiplier),
                fontSize: config.fontSize,
                chamferRadius: config.chamferRadius,
                imageScale: config.imageScale,
                density: config.density,
                friction: config.friction,
                restitution: config.restitution,
            };
        };

        const itemsBase = [
            { type: 'text', content: 'DESIGN', baseWidth: 150 },
            { type: 'image', content: 'hero-smile.svg', baseWidth: 180 },
            { type: 'text', content: 'USER EXPERIENCE', baseWidth: 220 },
            { type: 'text', content: 'INSPIRATION', baseWidth: 190 },
            { type: 'text', content: 'E-COMMERCE', baseWidth: 180 },
            { type: 'text', content: 'MOTION GRAPHIC', baseWidth: 200 },
            { type: 'text', content: 'WEB DESIGN', baseWidth: 190 },
            { type: 'text', content: 'BRAND', baseWidth: 140 },
            { type: 'text', content: 'USER INTERFACE', baseWidth: 210 },
            { type: 'text', content: 'PROTOTYPING', baseWidth: 190 },
            { type: 'text', content: 'TECHNOLOGY', baseWidth: 180 },
        ];

        const items = itemsBase.map(item => {
            const dims = getItemDimensions(item.baseWidth);
            return {
                ...item,
                width: dims.width,
                height: dims.height,
                fontSize: dims.fontSize,
                chamferRadius: dims.chamferRadius,
                imageScale: dims.imageScale,
                density: dims.density,
                friction: dims.friction,
                restitution: dims.restitution,
            };
        });

        const walls = [
            Bodies.rectangle(
                dimensions.width / 2,
                dimensions.height + 30,
                dimensions.width,
                60,
                {
                    isStatic: true,
                    friction: 1,
                    restitution: 0.05,
                    render: { fillStyle: 'transparent' },
                },
            ),
            Bodies.rectangle(0, dimensions.height / 2, 60, dimensions.height, {
                isStatic: true,
                friction: 1,
                restitution: 0.05,
                render: { fillStyle: 'transparent' },
            }),
            Bodies.rectangle(
                dimensions.width,
                dimensions.height / 2,
                60,
                dimensions.height,
                {
                    isStatic: true,
                    friction: 1,
                    restitution: 0.05,
                    render: { fillStyle: 'transparent' },
                },
            ),
        ];

        World.add(engine.world, walls);

        function createPillCanvas(item) {
            const scale = window.devicePixelRatio || 1;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = item.width * scale;
            canvas.height = item.height * scale;
            ctx.scale(scale, scale);

            ctx.fillStyle = '#1d1d1d';
            const radius = item.height / 2;
            ctx.beginPath();
            ctx.moveTo(radius, 0);
            ctx.lineTo(item.width - radius, 0);
            ctx.arcTo(item.width, 0, item.width, radius, radius);
            ctx.arcTo(
                item.width,
                item.height,
                item.width - radius,
                item.height,
                radius,
            );
            ctx.lineTo(radius, item.height);
            ctx.arcTo(0, item.height, 0, item.height - radius, radius);
            ctx.arcTo(0, 0, radius, 0, radius);
            ctx.closePath();
            ctx.fill();

            if (item.type === 'text') {
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${item.fontSize}px Darker Grotesque`;
                ctx.fillText(item.content, item.width / 2, item.height / 2);
            }

            return canvas;
        }

        function createBodies() {
            bodies = items.map((item, index) => {
                const canvas = createPillCanvas(item);

                const commonProperties = {
                    friction: item.friction,
                    restitution: item.restitution,
                    density: item.density,
                    chamfer: { radius: item.chamferRadius },
                    render: {
                        sprite: {
                            texture: canvas.toDataURL(),
                            xScale: 1,
                            yScale: 1,
                        },
                    },
                };

                const spacing = dimensions.width / (items.length + 1);
                const yOffset = Math.random() * 20;

                const body = Bodies.rectangle(
                    spacing * (index + 1),
                    -200 + yOffset, // Posición inicial un poco más arriba
                    item.width,
                    item.height,
                    commonProperties,
                );

                if (item.type === 'image') {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.src = item.content;
                    img.onload = () => {
                        const canvas = createPillCanvas(item);
                        const ctx = canvas.getContext('2d');
                        const scale = window.devicePixelRatio || 1;

                        const aspectRatio = img.width / img.height;
                        let drawWidth = item.width * item.imageScale * scale;
                        let drawHeight = drawWidth / aspectRatio;

                        if (
                            drawHeight >
                            item.height * item.imageScale * scale
                        ) {
                            drawHeight = item.height * item.imageScale * scale;
                            drawWidth = drawHeight * aspectRatio;
                        }

                        const x = (item.width * scale - drawWidth) / 2;
                        const y = (item.height * scale - drawHeight) / 2;

                        ctx.drawImage(img, x, y, drawWidth, drawHeight);
                        body.render.sprite.texture = canvas.toDataURL();
                    };
                }

                return body;
            });

            return bodies;
        }

        bodies = createBodies();

        const mouse = Mouse.create(boundary);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: { visible: false },
            },
        });

        // Iniciar el renderizado inmediatamente
        Render.run(render);

        // Retrasar el inicio de la física y la adición de los cuerpos
        setTimeout(() => {
            World.add(engine.world, [...bodies, mouseConstraint]);
            Runner.run(runner, engine);
        }, 500); // Retraso de 500ms antes de que empiecen a caer

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (window.innerWidth < 1024) {
                    World.clear(engine.world);
                    Engine.clear(engine);
                    render.canvas.remove();
                    return;
                }

                const newDimensions = updateContainerDimensions();
                if (!newDimensions) return;

                render.canvas.width = newDimensions.width;
                render.canvas.height = newDimensions.height;
                render.options.width = newDimensions.width;
                render.options.height = newDimensions.height;

                Matter.Body.setPosition(
                    walls[0],
                    Matter.Vector.create(
                        newDimensions.width / 2,
                        newDimensions.height + 30,
                    ),
                );
                Matter.Body.setPosition(
                    walls[2],
                    Matter.Vector.create(
                        newDimensions.width,
                        newDimensions.height / 2,
                    ),
                );

                World.clear(engine.world);
                Engine.clear(engine);
                initPhysics();
            }, 250);
        });
    }

    document.addEventListener('astro:page-load', initPhysics);
</script>

<style>
    .physics-section {
        min-height: 80vh;
        position: relative;
        overflow: hidden;
    }

    .physics-container {
        width: 100%;
        position: absolute;
        inset: 0;
        pointer-events: none;
    }

    .physics-boundary {
        width: 100%;
        position: absolute;
        inset: 0;
        pointer-events: auto;
    }

    .physics-container canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .content {
        position: relative;
        z-index: 10;
        text-align: center;
    }
</style>
