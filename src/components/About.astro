---

---

<section
    class="physics-section bg-lightpurple-pattern flex flex-col items-center justify-center text-center pt-16 md:pt-[100px] lg:pt-[160px] pb-20 md:pb-[150px] lg:pb-[200px] relative overflow-hidden"
>
    <div
        class="content relative z-10 w-full max-w-[1140px] px-4 pointer-events-none"
    >
        <h2
            class="text-6xl md:text-5xl lg:text-7xl xl:text-9xl text-primary-purple uppercase"
        >
            Una vez que tenemos claros tus objetivos,
        </h2>
        <p
            class="text-2xl md:text-2xl lg:text-4xl xl:text-5xl text-primary-purple uppercase font-bold mt-6"
        >
            Podemos desarrollar una estrategia y un plan para alcanzarlos. Esto
            incluirá la identificación de los pasos necesarios, los recursos y
            los posibles obstáculos a superar.
        </p>
    </div>
    <div class="physics-boundary absolute z-0 hidden lg:block"></div>
    <div class="physics-container absolute z-0 hidden lg:block"></div>
</section>

<script>
    import Matter from 'matter-js';

    function initPhysics() {
        if (window.innerWidth < 1024) return;

        const Engine = Matter.Engine;
        const Render = Matter.Render;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Mouse = Matter.Mouse;
        const MouseConstraint = Matter.MouseConstraint;
        const Runner = Matter.Runner;

        const container = document.querySelector('.physics-container');
        const boundary = document.querySelector('.physics-boundary');
        if (!container || !boundary) return;

        const content = document.querySelector('.content');
        if (!content) return;

        const updateContainerDimensions = () => {
            const section = container.closest('.physics-section');
            if (section) {
                const contentRect = content.getBoundingClientRect();
                const sectionRect = section.getBoundingClientRect();
                const contentBottom = contentRect.bottom - sectionRect.top;

                container.style.top = `${contentBottom}px`;
                container.style.height = `${sectionRect.height - contentBottom}px`;
                boundary.style.top = `${contentBottom}px`;
                boundary.style.height = `${sectionRect.height - contentBottom}px`;

                return {
                    width: container.clientWidth,
                    height: container.clientHeight,
                    contentBottom,
                };
            }
            return null;
        };

        const dimensions = updateContainerDimensions();
        if (!dimensions) return;

        const engine = Engine.create({
            gravity: { x: 0, y: 1, scale: 0.001 },
        });

        const render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: dimensions.width,
                height: dimensions.height,
                wireframes: false,
                background: 'transparent',
                pixelRatio: window.devicePixelRatio,
            },
        });

        const runner = Runner.create();
        Runner.run(runner, engine);

        // Función para obtener las dimensiones según el tamaño de la pantalla
        const getItemDimensions = baseWidth => {
            const isLargeScreen = window.innerWidth >= 1536; // Pantallas grandes
            const scale = isLargeScreen ? 1 : 0.55; // 55% del tamaño para pantallas más pequeñas

            return {
                width: Math.round(baseWidth * scale),
                height: Math.round(60 * scale), // Altura base de 60px
                fontSize: isLargeScreen ? 24 : 13, // Fuente más pequeña para pantallas pequeñas
                chamferRadius: isLargeScreen ? 15 : 8,
                imageScale: isLargeScreen ? 0.8 : 0.9, // Escala de imagen más grande en pantallas pequeñas
            };
        };

        // Definición de elementos con sus anchos base
        const itemsBase = [
            { type: 'text', content: 'DESIGN', baseWidth: 150 },
            { type: 'image', content: 'hero-smile.svg', baseWidth: 180 },
            { type: 'text', content: 'USER EXPERIENCE', baseWidth: 220 },
            { type: 'text', content: 'INSPIRATION', baseWidth: 190 },
            { type: 'text', content: 'E-COMMERCE', baseWidth: 180 },
            { type: 'text', content: 'MOTION GRAPHIC', baseWidth: 200 },
            { type: 'text', content: 'WEB DESIGN', baseWidth: 190 },
            { type: 'text', content: 'BRAND', baseWidth: 140 },
            { type: 'text', content: 'USER INTERFACE', baseWidth: 210 },
            { type: 'text', content: 'PROTOTYPING', baseWidth: 190 },
            { type: 'text', content: 'TECHNOLOGY', baseWidth: 180 },
        ];

        // Aplicar dimensiones responsivas
        const items = itemsBase.map(item => {
            const dims = getItemDimensions(item.baseWidth);
            return {
                ...item,
                width: dims.width,
                height: dims.height,
                fontSize: dims.fontSize,
                chamferRadius: dims.chamferRadius,
                imageScale: dims.imageScale,
            };
        });

        const walls = [
            Bodies.rectangle(
                dimensions.width / 2,
                dimensions.height + 30,
                dimensions.width,
                60,
                {
                    isStatic: true,
                    friction: 0.8,
                    restitution: 0.2,
                    render: { fillStyle: 'transparent' },
                },
            ),
            Bodies.rectangle(0, dimensions.height / 2, 60, dimensions.height, {
                isStatic: true,
                friction: 0.8,
                restitution: 0.2,
                render: { fillStyle: 'transparent' },
            }),
            Bodies.rectangle(
                dimensions.width,
                dimensions.height / 2,
                60,
                dimensions.height,
                {
                    isStatic: true,
                    friction: 0.8,
                    restitution: 0.2,
                    render: { fillStyle: 'transparent' },
                },
            ),
        ];

        function createPillCanvas(item) {
            const scale = window.devicePixelRatio || 1;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = item.width * scale;
            canvas.height = item.height * scale;
            ctx.scale(scale, scale);

            ctx.fillStyle = '#1d1d1d';
            const radius = item.height / 2;
            ctx.beginPath();
            ctx.moveTo(radius, 0);
            ctx.lineTo(item.width - radius, 0);
            ctx.arcTo(item.width, 0, item.width, radius, radius);
            ctx.arcTo(
                item.width,
                item.height,
                item.width - radius,
                item.height,
                radius,
            );
            ctx.lineTo(radius, item.height);
            ctx.arcTo(0, item.height, 0, item.height - radius, radius);
            ctx.arcTo(0, 0, radius, 0, radius);
            ctx.closePath();
            ctx.fill();

            if (item.type === 'text') {
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${item.fontSize}px Darker Grotesque`;
                ctx.fillText(item.content, item.width / 2, item.height / 2);
            }

            return canvas;
        }

        const bodies = items.map(item => {
            const canvas = createPillCanvas(item);

            const commonProperties = {
                friction: 0.8,
                restitution: 0.2,
                density: 0.001,
                chamfer: { radius: item.chamferRadius },
                render: {
                    sprite: {
                        texture: canvas.toDataURL(),
                        xScale: 1,
                        yScale: 1,
                    },
                },
            };

            const body = Bodies.rectangle(
                Math.random() * (dimensions.width - item.width) +
                    item.width / 2,
                dimensions.height - 100,
                item.width,
                item.height,
                commonProperties,
            );

            if (item.type === 'image') {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.src = item.content;
                img.onload = () => {
                    const canvas = createPillCanvas(item);
                    const ctx = canvas.getContext('2d');
                    const scale = window.devicePixelRatio || 1;

                    const aspectRatio = img.width / img.height;
                    let drawWidth = item.width * item.imageScale * scale;
                    let drawHeight = drawWidth / aspectRatio;

                    if (drawHeight > item.height * item.imageScale * scale) {
                        drawHeight = item.height * item.imageScale * scale;
                        drawWidth = drawHeight * aspectRatio;
                    }

                    const x = (item.width * scale - drawWidth) / 2;
                    const y = (item.height * scale - drawHeight) / 2;

                    ctx.drawImage(img, x, y, drawWidth, drawHeight);
                    body.render.sprite.texture = canvas.toDataURL();
                };
            }

            return body;
        });

        const mouse = Mouse.create(boundary);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: { visible: false },
            },
        });

        World.add(engine.world, [...walls, ...bodies, mouseConstraint]);
        Render.run(render);

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (window.innerWidth < 1024) {
                    World.clear(engine.world);
                    Engine.clear(engine);
                    render.canvas.remove();
                    return;
                }

                const newDimensions = updateContainerDimensions();
                if (!newDimensions) return;

                render.canvas.width = newDimensions.width;
                render.canvas.height = newDimensions.height;
                render.options.width = newDimensions.width;
                render.options.height = newDimensions.height;

                Matter.Body.setPosition(
                    walls[0],
                    Matter.Vector.create(
                        newDimensions.width / 2,
                        newDimensions.height + 30,
                    ),
                );
                Matter.Body.setPosition(
                    walls[2],
                    Matter.Vector.create(
                        newDimensions.width,
                        newDimensions.height / 2,
                    ),
                );

                World.clear(engine.world);
                Engine.clear(engine);
                initPhysics();
            }, 250);
        });
    }

    document.addEventListener('astro:page-load', initPhysics);
</script>

<style>
    .physics-section {
        min-height: 80vh;
        position: relative;
        overflow: hidden;
    }

    .physics-container {
        width: 100%;
        position: absolute;
        inset: 0;
        pointer-events: none;
    }

    .physics-boundary {
        width: 100%;
        position: absolute;
        inset: 0;
        pointer-events: auto;
    }

    .physics-container canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    .content {
        position: relative;
        z-index: 10;
        text-align: center;
    }
</style>
